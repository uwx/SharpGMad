using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using HSNXT.Greed.Unswepper;

namespace HSNXT.Greed.SwepMerger
{
    internal static class Program
    {
        private static readonly Regex AddSelfPruneRegex = new Regex(
            @"AddCSLuaFile\s*\(\s*\)", RegexOptions.Compiled
        );
        
        private static int Main(string[] args)
        {
            if (args.Length == 0 || args[0] == "--help" || args[0] == "-help" || args[0] == "-h")
            {
                Console.WriteLine("Merges folder or file-based SWEPs and SENTs into a single file using " +
                                  "weapons.Register / scripted_ents.Register calls.");
                Console.WriteLine("Works better with the changes from https://github.com/Facepunch/garrysmod/pull/1300 applied.");
                Console.WriteLine();
                Console.WriteLine("Usage:");
                Console.WriteLine("    dotnet SwepMerger.dll <addon root path>");
                return 1;
            }

            GetCombinedClasses(args[0], out var sweps, out var sents);

            var fileOutput = new StringBuilder(
                "-- This file contains SWEPs and/or SENTs generated by Unswepper and SwepMerger.\n" + 
                $"-- Automatically generated at {DateTimeOffset.UtcNow}.\n" +
                "-- Changes to this file might be erased upon new generation.\n\n"
            );
            
            var hasAddCsLuaFile = false;
            for (var i = 0; i < sweps.Length; i++)
            {
                if (!PruneCsIncludes(ref sweps[i]) || hasAddCsLuaFile) continue;

                hasAddCsLuaFile = true;
                fileOutput.Append("AddCSLuaFile()\n\n");
            }
            
            for (var i = 0; i < sents.Length; i++)
            {
                if (!PruneCsIncludes(ref sents[i]) || hasAddCsLuaFile) continue;

                hasAddCsLuaFile = true;
                fileOutput.Append("AddCSLuaFile()\n\n");
            }

            foreach (var (weaponName, luaCode) in sweps)
            {
                AppendEntity(fileOutput, "SWEP", "weapons.Register", weaponName, luaCode);
            }

            foreach (var (entityName, luaCode) in sents)
            {
                AppendEntity(fileOutput, "ENT", "scripted_ents.Register", entityName, luaCode);
            }

            File.WriteAllText($"{args[0]}/lua/autorun/zz_sweps_merged.lua", fileOutput.ToString(), Encoding.UTF8);
            
            Console.WriteLine("Finished writing lua/autorun/zz_sweps_merged.lua.");

            return 0;
        }

        private static void AppendEntity(StringBuilder sb, string local, string regFunc, string className, string luaCode)
        {
            sb.Append("do -- ").Append(className).Append('\n');
            sb.Append($"local {local} = {{}}\n\n");
            
            sb.Append(luaCode).Append("\n\n");

            sb.Append($"print \"[SwepMerger] Registering {local} {className}\"\n");
            sb.Append($"{regFunc}({local}, \"{className}\")\n");
            sb.Append("end\n\n");
        }

        private static void GetCombinedClasses(
            string path,
            out (string weaponName, string luaCode)[] outSweps,
            out (string entityName, string luaCode)[] outSents
        )
        {
            var foundClasses = new HashSet<string>();
            var sweps = new List<(string weaponName, string luaCode)>();
            var sents = new List<(string entityName, string luaCode)>();

            var duplicates = 0;

            var items = Directory.EnumerateDirectories($"{path}/lua_pre/weapons").Select(e => (true, e))
                .Concat(Directory.EnumerateDirectories($"{path}/lua_pre/entities").Select(e => (false, e)));

            var files = Directory.EnumerateFiles($"{path}/lua_pre/weapons").Select(e => (true, e))
                .Concat(Directory.EnumerateFiles($"{path}/lua_pre/entities").Select(e => (false, e)));

            foreach (var (isWeapon, dir) in items)
            {
                var output = UnswepperProgram.GetMergedSwepFileContents(dir);

                var className = Path.GetFileName(dir);
                if (!foundClasses.Add(className))
                {
                    duplicates++;
                    continue;
                }

                (isWeapon ? sweps : sents).Add((className, output));
            }

            foreach (var (isWeapon, file) in files)
            {
                if (!file.EndsWith(".lua")) continue;

                var className = Path.GetFileNameWithoutExtension(file);
                if (!foundClasses.Add(className))
                {
                    duplicates++;
                    continue;
                }

                (isWeapon ? sweps : sents).Add((className, File.ReadAllText(file, Encoding.UTF8)));
            }

            Console.WriteLine($"Collapsed {sweps.Count} sweps, {sents.Count} sents ({sweps.Count + sents.Count} total). Ignored {duplicates} duplicates.");

            outSweps = sweps.ToArray();
            outSents = sents.ToArray();
        }

        private static bool PruneCsIncludes(ref (string className, string code) entity)
        {
            var oldCode = entity.code;
            if (!oldCode.Contains("AddCSLuaFile"))
            {
                return false;
            }

            entity.code = AddSelfPruneRegex.Replace(oldCode, ""); // TODO test to make sure no copy
            return entity.code.Length != oldCode.Length;
        }
    }
}